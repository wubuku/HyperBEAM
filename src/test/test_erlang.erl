%%% ====================================================================
%%% Erlang 测试文件 - 为 Java 开发者打造
%%% ====================================================================
%%% 这个测试文件包含了 Erlang 语言的核心知识点，专为 Erlang 小白设计
%%% 每个测试函数都有详细的注释，帮助你理解 Erlang 的基本概念
%%%
%%% 运行测试：
%%%   rebar3 eunit --module=test_erlang
%%%
%%% 学习路径：
%%%   1. 数字类型 - 整数、浮点数、进制表示
%%%   2. 原子类型 - 常量、布尔值、短路求值
%%%   3. 二进制与字符串 - 二进制操作、字符串处理
%%%   4. 变量与模式匹配 - 变量绑定、模式匹配
%%%   5. 列表 - 列表操作、列表函数
%%%   6. 元组 - 元组操作、元素访问
%%%   7. 映射 - 映射操作、键值对管理
%%%   8. 函数 - 匿名函数、模式匹配函数
%%%   9. 守卫表达式 - 条件判断、类型检查
%%%  10. 控制流 - if 表达式、case 表达式
%%%  11. 递归 - 递归函数、尾递归
%%%  12. 高阶函数 - 映射、过滤、折叠
%%%  13. 标准库 - 数学、字符串、列表模块
%%%  14. 错误处理 - try-catch 异常处理
%%%  15. 位语法 - 位级操作、模式匹配
%%%  16. 列表推导式 - 简洁的列表生成
%%%  17. 记录 - 结构体类似的数据结构
%%% ====================================================================

-module(test_erlang).
-include_lib("eunit/include/eunit.hrl").

%%% ====================================================================
%%% Part 1: 数字类型 (Numbers)
%%% ====================================================================
%%% Erlang 的数字类型非常强大：
%%% - 整数：任意精度，自动处理大整数
%%% - 浮点数：64位双精度
%%% - 支持不同进制：16进制（16#）、2进制（2#）
%%% - 支持下划线分隔：1_000_000 提高可读性
%%% - 比较运算符：<, =<, >, >=, ==, /=, =:=, /==
%%%   * == ：值比较（会自动类型转换）
%%%   * =:= ：严格比较（类型和值都要相同）
%%% ====================================================================
numbers_test() ->
    %% 第2章：基础类型 - Part 1: 数字类型
    io:format("\n=== 第2章：基础类型 - Part 1: 数字类型 ===\n"),
    
    %% 基本算术运算
    ?assertEqual(7, 3 + 4),       % 加法
    ?assertEqual(3, 10 div 3),     % 整数除法
    ?assertEqual(1, 10 rem 3),     % 取余数
    ?assertEqual(2.5, 5 / 2),      % 浮点数除法
    
    %% 不同进制表示
    ?assertEqual(255, 16#FF),      % 16进制
    ?assertEqual(10, 2#1010),      % 2进制
    
    %% 可读性增强（下划线分隔）
    ?assertEqual(1000000, 1_000_000),
    
    %% 比较运算符
    ?assert(5 < 10),               % 小于
    ?assert(5 =< 5),               % 小于等于
    ?assert(5 == 5.0),             % 值相等（自动类型转换）
    ?assertNot(5 =:= 5.0).         % 严格相等（类型不同）

%%% ====================================================================
%%% Part 2: 原子类型 (Atoms)
%%% ====================================================================
%%% 原子是 Erlang 中的常量标识符，类似于 Java 中的枚举常量：
%%% - 以小写字母开头，或用单引号括起来
%%% - 常见的原子：ok, error, true, false, undefined
%%% - 布尔值也是原子：true, false
%%% - 布尔运算符：andalso, orelse, not
%%%   * andalso：短路与（左边为 false 时停止计算）
%%%   * orelse：短路或（左边为 true 时停止计算）
%%%   * not：逻辑非
%%% ====================================================================
atoms_test() ->
    %% 第2章：基础类型 - Part 2: 原子类型
    io:format("\n=== 第2章：基础类型 - Part 2: 原子类型 ===\n"),
    
    ?assertEqual(ok, ok),         % 原子比较
    ?assert(is_atom(true)),       % 检查是否为原子
    ?assert(is_atom(false)),      % 检查是否为原子
    ?assert(is_atom(ok)),         % 检查是否为原子
    ?assert(true andalso true),   % 逻辑与
    ?assert(false orelse true),   % 逻辑或
    ?assert(not false).           % 逻辑非

%%% ====================================================================
%%% Part 2: 短路求值 (Short Circuit Evaluation)
%%% ====================================================================
%%% 短路求值是一种优化技术：
%%% - andalso：如果左边表达式为 false，右边表达式不会执行
%%% - orelse：如果左边表达式为 true，右边表达式不会执行
%%% 这在处理可能导致错误的表达式时非常有用
%%% ====================================================================
short_circuit_test() ->
    %% 第2章：基础类型 - Part 2: 短路求值
    io:format("\n=== 第2章：基础类型 - Part 2: 短路求值 ===\n"),
    
    %% andalso：左边为 false 时，右边的表达式不会执行（不会崩溃！）
    ?assertNot(false andalso (1/0 == 0)), % 这里 1/0 不会被计算
    
    %% orelse：左边为 true 时，右边的表达式不会执行（不会崩溃！）
    ?assert(true orelse (1/0 == 0)).      % 这里 1/0 不会被计算

%%% ====================================================================
%%% Part 2: 标签元组 (Tagged Tuples)
%%% ====================================================================
%%% 标签元组是 Erlang 中常用的返回值模式：
%%% - 格式：{标签, 值}
%%% - 常见模式：{ok, 结果} 表示成功，{error, 原因} 表示失败
%%% - 可以通过模式匹配提取值
%%% 这是 Erlang 中替代异常处理的常用方式
%%% ====================================================================
tagged_tuples_test() ->
    %% 第2章：基础类型 - Part 2: 标签元组
    io:format("\n=== 第2章：基础类型 - Part 2: 标签元组 ===\n"),
    
    Result = {ok, 42},            % 成功结果
    {ok, Value} = Result,         % 模式匹配提取值
    ?assertEqual(42, Value),      % 验证提取的值
    
    ErrorResult = {error, not_found},  % 错误结果
    ?assertMatch({error, _}, ErrorResult).  % 验证错误模式

%%% ====================================================================
%%% Part 3: 二进制与字符串 (Binaries & Strings)
%%% ====================================================================
%%% 二进制是 Erlang 中处理原始字节数据的高效方式：
%%% - 语法：<<数据>>
%%% - 字符串在 Erlang 中有两种表示：
%%%   1. 字符列表："hello" 实际上是 [104, 101, 108, 108, 111]
%%%   2. 二进制字符串：<<"hello">> 更高效
%%% - 常用操作：
%%%   * byte_size/1：获取二进制大小
%%%   * 二进制模式匹配：提取部分二进制
%%%   * 二进制拼接：使用 /binary 后缀
%%% ====================================================================
binaries_test() ->
    %% 第2章：基础类型 - Part 3: 二进制与字符串
    io:format("\n=== 第2章：基础类型 - Part 3: 二进制与字符串 ===\n"),
    
    %% 获取二进制大小
    ?assertEqual(5, byte_size(<<"hello">>)),
    
    %% 检查是否为二进制
    ?assert(is_binary(<<"test">>)),
    
    %% 二进制模式匹配（提取第一个字节和剩余部分）
    %% /binary: 表示 Rest 必须是完整的二进制（8位整数倍长度）
    <<H:8, Rest/binary>> = <<"hello">>,
    ?assertEqual(104, H),           % 'h' 的 ASCII 值
    ?assertEqual(<<"ello">>, Rest), % 剩余部分
    
    %% 二进制拼接
    ?assertEqual(<<"hello world">>, <<<<"hello">>/binary, " world">>),
    
    %% 使用 ASCII 值创建二进制
    ?assertEqual(<<"hello">>, <<104, 101, 108, 108, 111>>).

%%% ====================================================================
%%% Part 4: 变量与模式匹配 (Variables & Pattern Matching)
%%% ====================================================================
%%% 变量特性：
%%% - 变量名必须以大写字母开头
%%% - 变量是不可变的（一旦绑定值，就不能改变）
%%% - = 不是赋值，而是模式匹配操作符
%%%
%%% 模式匹配：
%%% - Erlang 的核心特性，类似于 Java 的解构赋值
%%% - 可以匹配元组、列表、映射等数据结构
%%% - 使用 _ 作为通配符，表示忽略某个值
%%% ====================================================================
variables_test() ->
    %% 第2章：基础类型 - Part 4: 变量与模式匹配
    io:format("\n=== 第2章：基础类型 - Part 4: 变量与模式匹配 ===\n"),
    
    X = 42,               % 变量绑定
    ?assertEqual(42, X),  % 验证变量值
    
    Y = X + 8,            % 创建新变量，基于现有变量
    ?assertEqual(50, Y).  % 验证新变量值

pattern_matching_test() ->
    %% 第2章：基础类型 - Part 4: 模式匹配
    io:format("\n=== 第2章：基础类型 - Part 4: 模式匹配 ===\n"),
    
    %% 元组模式匹配
    {A, B} = {10, 20},    % 匹配元组，提取两个值
    ?assertEqual(10, A),  % 验证第一个值
    ?assertEqual(20, B),  % 验证第二个值
    
    %% 列表模式匹配
    [H|T] = [1, 2, 3],    % 匹配列表，提取头部和尾部
    ?assertEqual(1, H),   % 验证头部（第一个元素）
    ?assertEqual([2, 3], T),  % 验证尾部（剩余元素）
    
    %% 使用通配符 _ 忽略某些值
    {_, X, _} = {a, b, c},    % 只关心第二个元素
    ?assertEqual(b, X).       % 验证提取的值

%%% ====================================================================
%%% Part 5: 列表 (Lists)
%%% ====================================================================
%%% 列表是 Erlang 中最常用的数据结构之一：
%%% - 列表是由元素组成的序列，如 [1, 2, 3]
%%% - 列表的构造：
%%%   * 使用 | 操作符：[Head | Tail]，其中 Tail 也是一个列表
%%%   * 空列表：[]
%%% - 常用操作：
%%%   * length/1：获取列表长度
%%%   * hd/1：获取列表头部（第一个元素）
%%%   * tl/1：获取列表尾部（除第一个元素外的所有元素）
%%%   * lists:reverse/1：反转列表
%%% ====================================================================
lists_test() ->
    %% 第3章：数据结构 - Part 5: 列表
    io:format("\n=== 第3章：数据结构 - Part 5: 列表 ===\n"),
    
    %% 列表构造（使用 | 操作符）
    ?assertEqual([1, 2, 3], [1 | [2 | [3 | []]]]),
    
    %% 列表构造（混合语法）
    ?assertEqual([1, 2, 3, 4], [1, 2 | [3, 4]]),
    
    %% 列表操作
    ?assertEqual(3, length([1, 2, 3])),        % 获取长度
    ?assertEqual([3, 2, 1], lists:reverse([1, 2, 3])),  % 反转列表
    ?assertEqual([2, 3, 4], tl([1, 2, 3, 4])),  % 获取尾部
    ?assertEqual(1, hd([1, 2, 3])).            % 获取头部

%%% ====================================================================
%%% Part 6: 元组 (Tuples)
%%% ====================================================================
%%% 元组是 Erlang 中固定大小的数据结构：
%%% - 元组用大括号表示，如 {1, 2, 3}
%%% - 元组的大小在创建时确定，不能改变
%%% - 元组适合存储固定数量的相关数据
%%% - 常用操作：
%%%   * tuple_size/1：获取元组大小
%%%   * element/2：获取指定位置的元素（索引从 1 开始）
%%%   * setelement/3：更新指定位置的元素（返回新元组）
%%% ====================================================================
tuples_test() ->
    %% 第3章：数据结构 - Part 6: 元组
    io:format("\n=== 第3章：数据结构 - Part 6: 元组 ===\n"),
    
    %% 获取元组大小
    ?assertEqual(3, tuple_size({1, 2, 3})),
    
    %% 获取指定位置的元素（索引从 1 开始）
    ?assertEqual(2, element(2, {1, 2, 3})),
    
    %% 更新指定位置的元素（返回新元组，原元组不变）
    ?assertEqual({1, 42, 3}, setelement(2, {1, 2, 3}, 42)).

%%% ====================================================================
%%% Part 7: 映射 (Maps)
%%% ====================================================================
%%% 映射是 Erlang 中的键值对数据结构，类似于 Java 的 HashMap：
%%% - 映射用 #{key => value} 表示
%%% - 映射是不可变的，操作会返回新映射
%%% - 常用操作：
%%%   * maps:get/2：获取指定键的值
%%%   * maps:put/3：添加或更新键值对
%%%   * maps:remove/2：移除指定键
%%%   * maps:is_key/2：检查键是否存在
%%% ====================================================================
maps_test() ->
    %% 第3章：数据结构 - Part 7: 映射
    io:format("\n=== 第3章：数据结构 - Part 7: 映射 ===\n"),
    
    Map = #{a => 1, b => 2},     % 创建映射
    
    %% 获取值
    ?assertEqual(1, maps:get(a, Map)),
    ?assertEqual(2, maps:get(b, Map)),
    
    %% 添加新键值对（返回新映射）
    ?assertEqual(#{a => 1, b => 2, c => 3}, maps:put(c, 3, Map)),
    
    %% 移除键（返回新映射）
    ?assertEqual(#{a => 1}, maps:remove(b, Map)),
    
    %% 检查键是否存在
    ?assert(maps:is_key(a, Map)),
    ?assertNot(maps:is_key(c, Map)).

%%% ====================================================================
%%% Part 8: 函数 (Functions)
%%% ====================================================================
%%% 函数是 Erlang 中的核心概念：
%%% - 匿名函数：使用 fun() -> ... end 创建
%%% - 命名函数：在模块中定义的函数
%%% - 函数可以进行模式匹配
%%% - 函数是一等公民，可以作为参数传递
%%% ====================================================================
functions_test() ->
    %% 第4章：函数 - Part 8: 函数
    io:format("\n=== 第4章：函数 - Part 8: 函数 ===\n"),
    
    %% 匿名函数（lambda 函数）
    Add = fun(X, Y) -> X + Y end,
    ?assertEqual(5, Add(2, 3)),
    
    %% 带模式匹配的函数
    Greet = fun
        (name, Name) -> "Hello " ++ Name;
        (greeting, Msg) -> Msg
    end,
    ?assertEqual("Hello World", Greet(name, "World")),
    ?assertEqual("Hi there", Greet(greeting, "Hi there")).

%%% ====================================================================
%%% Part 9: 守卫表达式 (Guards)
%%% ====================================================================
%%% 守卫表达式用于函数和 case 语句中，用于条件判断：
%%% - 语法：when 条件1, 条件2 ->
%%% - 条件可以是：
%%%   * 比较运算符：==, /=, <, =<, >, >=
%%%   * 算术表达式：+, -, *, /, div, rem
%%%   * 类型检查函数：is_integer/1, is_float/1, is_list/1 等
%%%   * 逻辑运算符：andalso, orelse, not
%%% - 多个条件用逗号分隔（表示 AND 关系）
%%% - 多个守卫用分号分隔（表示 OR 关系）
%%% ====================================================================
guards_test() ->
    %% 第4章：函数 - Part 9: 守卫表达式
    io:format("\n=== 第4章：函数 - Part 9: 守卫表达式 ===\n"),
    
    %% 检查偶数的函数
    IsEven = fun(X) when X rem 2 == 0 -> true; (X) when X rem 2 == 1 -> false end,
    ?assert(IsEven(2)),
    ?assertNot(IsEven(3)),
    
    %% 检查正数的函数
    IsPositive = fun(X) when X > 0 -> true; (_) -> false end,
    ?assert(IsPositive(5)),
    ?assertNot(IsPositive(-1)).

%%% ====================================================================
%%% Part 10: 控制流 (Control Flow)
%%% ====================================================================
%%% Erlang 中的控制流结构：
%%%
%%% 1. if 表达式：
%%%    - 语法：if 条件1 -> 表达式1; 条件2 -> 表达式2; true -> 表达式3 end
%%%    - 必须包含一个 true 分支作为默认情况
%%%    - if 表达式本身是有返回值的
%%%
%%% 2. case 表达式：
%%%    - 语法：case 表达式 of 模式1 -> 结果1; 模式2 -> 结果2; _ -> 结果3 end
%%%    - 基于模式匹配进行分支选择
%%%    - 也可以包含守卫表达式
%%%    - case 表达式本身是有返回值的
%%% ====================================================================
control_flow_test() ->
    %% 第5章：控制流 - Part 10: 控制流
    io:format("\n=== 第5章：控制流 - Part 10: 控制流 ===\n"),
    
    %% if 表达式
    X = 5,
    Result1 = if
        X > 10 -> big;
        X > 0 -> small;
        true -> zero
    end,
    ?assertEqual(small, Result1),
    
    %% case 表达式
    Result2 = case X of
        1 -> one;
        2 -> two;
        _ -> other
    end,
    ?assertEqual(other, Result2).

%%% ====================================================================
%%% Part 11: 递归 (Recursion)
%%% ====================================================================
%%% 递归是 Erlang 中实现循环的主要方式：
%%% - 函数调用自身来解决问题
%%% - 必须有一个基本情况（终止条件）
%%% - 常见的递归例子：
%%%   * 阶乘：factorial(0) = 1, factorial(N) = N * factorial(N-1)
%%%   * 斐波那契数列：fib(0) = 0, fib(1) = 1, fib(N) = fib(N-1) + fib(N-2)
%%%
%%% 注意：
%%% - 递归可能会导致栈溢出，对于大问题应使用尾递归
%%% - 尾递归：递归调用是函数的最后一个操作
%%% ====================================================================
recursion_test() ->
    %% 第5章：控制流 - Part 11: 递归
    io:format("\n=== 第5章：控制流 - Part 11: 递归 ===\n"),
    
    %% 阶乘函数（非尾递归）
    Factorial = fun Fact(N) when N == 0 -> 1; Fact(N) when N > 0 -> N * Fact(N-1) end,
    ?assertEqual(1, Factorial(0)),  % 基本情况
    ?assertEqual(1, Factorial(1)),  % 1! = 1
    ?assertEqual(120, Factorial(5)), % 5! = 5 * 4 * 3 * 2 * 1 = 120
    
    %% 斐波那契数列（非尾递归）
    Fibonacci = fun Fib(N) when N == 0 -> 0; Fib(N) when N == 1 -> 1; Fib(N) -> Fib(N-1) + Fib(N-2) end,
    ?assertEqual(0, Fibonacci(0)),  % 基本情况
    ?assertEqual(1, Fibonacci(1)),  % 基本情况
    ?assertEqual(5, Fibonacci(5)).  % fib(5) = fib(4) + fib(3) = 3 + 2 = 5

%%% ====================================================================
%%% Part 12: 高阶函数 (Higher-order Functions)
%%% ====================================================================
%%% 高阶函数是指可以接受函数作为参数或返回函数的函数：
%%% - Erlang 中函数是一等公民，可以作为参数传递
%%% - 常见的高阶函数：
%%%   1. lists:map/2：将函数应用到列表的每个元素，返回新列表
%%%      - 语法：lists:map(fun(X) -> ... end, List)
%%%   2. lists:filter/2：根据条件过滤列表元素，返回符合条件的元素
%%%      - 语法：lists:filter(fun(X) -> ... end, List)
%%%   3. lists:foldl/3：从左到右折叠列表，累加计算结果
%%%      - 语法：lists:foldl(fun(X, Acc) -> ... end, InitialAcc, List)
%%% ====================================================================
higher_order_functions_test() ->
    %% 第5章：控制流 - Part 12: 高阶函数
    io:format("\n=== 第5章：控制流 - Part 12: 高阶函数 ===\n"),
    
    %% map：将每个元素乘以 2
    ?assertEqual([2, 4, 6], lists:map(fun(X) -> X * 2 end, [1, 2, 3])),
    
    %% filter：过滤出偶数
    ?assertEqual([2, 4], lists:filter(fun(X) -> X rem 2 == 0 end, [1, 2, 3, 4])),
    
    %% foldl：计算列表元素的和
    ?assertEqual(6, lists:foldl(fun(X, Acc) -> X + Acc end, 0, [1, 2, 3])).

%%% ====================================================================
%%% Part 13: 模块和标准库 (Modules and Standard Library)
%%% ====================================================================
%%% Erlang 的代码组织和标准库：
%%%
%%% 1. 模块：
%%%    - 每个 .erl 文件是一个模块
%%%    - 模块名必须与文件名一致
%%%    - 使用 -module(module_name). 声明
%%%    - 使用 -export([function1/1, function2/2]). 导出函数
%%%
%%% 2. 标准库模块：
%%%    - math：数学函数
%%%    - string：字符串处理（传统）
%%%    - lists：列表操作
%%%    - maps：映射操作
%%%    - io：输入输出
%%%
%%% 3. 模块函数调用：
%%%    - 语法：module_name:function_name(argument1, argument2)
%%% ====================================================================
modules_test() ->
    %% 第6章：标准库 - Part 13: 模块和标准库
    io:format("\n=== 第6章：标准库 - Part 13: 模块和标准库 ===\n"),
    
    %% 数学模块
    ?assertEqual(4.0, math:sqrt(16)),          % 平方根
    ?assertEqual(1.0, math:sin(math:pi() / 2)),  % 正弦函数
    
    %% 字符串模块（传统）
    ?assertEqual("hello world", string:concat("hello ", "world")),  % 字符串拼接
    ?assertEqual(5, string:length("hello")),         % 字符串长度
    
    %% 列表模块
    ?assertEqual([1, 2, 3, 4, 5], lists:seq(1, 5)),     % 生成序列
    ?assertEqual([1, 2, 3, 4, 5], lists:sort([3, 1, 5, 2, 4])).  % 排序

%%% ====================================================================
%%% Part 14: 错误处理 (Error Handling)
%%% ====================================================================
%%% Erlang 中的错误处理机制：
%%%
%%% 1. Try-catch 表达式：
%%%    - 用于捕获和处理异常
%%%    - 语法：
%%%      try
%%%          可能出错的表达式
%%%      of
%%%          成功结果模式 -> 处理成功
%%%      catch
%%%          error:Error -> 处理错误
%%%      end
%%%
%%% 2. 错误类型：
%%%    - error:badarith：算术错误（如除零）
%%%    - error:badmatch：模式匹配失败
%%%    - error:function_clause：函数子句不匹配
%%%
%%% 3. 注意：
%%%    - Erlang 推荐使用 {ok, Result} / {error, Reason} 模式
%%%    - Try-catch 应谨慎使用
%%% ====================================================================
error_handling_test() ->
    %% 第6章：标准库 - Part 14: 错误处理
    io:format("\n=== 第6章：标准库 - Part 14: 错误处理 ===\n"),
    
    %% Try-catch 捕获除零错误
    Result = try
        1 / 0  % 这里会产生除零错误
    catch
        error:badarith -> "division by zero"  % 捕获算术错误
    end,
    ?assertEqual("division by zero", Result).

%%% ====================================================================
%%% Part 15: 位语法 (Bit Syntax)
%%% ====================================================================
%%% 位语法是 Erlang 中处理二进制数据的强大特性：
%%% - 用于精确控制位级别的数据
%%% - 语法：<<模式1, 模式2, ...>>
%%% - 模式格式：变量:大小/类型
%%%   * 大小：位的数量
%%%   * 类型：如 integer, float, binary 等
%%%
%%% 位语法的应用：
%%% - 网络协议解析
%%% - 二进制文件格式处理
%%% - 高效的数据序列化/反序列化
%%%
%%% 注意：
%%% - 默认是大端字节序（big-endian）
%%% - 8 位 = 1 字节
%%% ====================================================================
bit_syntax_test() ->
    %% 第6章：标准库 - Part 15: 位语法
    io:format("\n=== 第6章：标准库 - Part 15: 位语法 ===\n"),
    
    %% 16位整数的位模式匹配
    <<A:16, B:16>> = <<0, 10, 0, 20>>,
    ?assertEqual(10, A),   % 0*256 + 10 = 10
    ?assertEqual(20, B),   % 0*256 + 20 = 20
    
    %% 混合位大小的模式匹配
    <<X:8, Y:24>> = <<1, 2, 3, 4>>,
    ?assertEqual(1, X),    % 第一个字节
    ?assertEqual(131844, Y).  % 2*65536 + 3*256 + 4 = 131844

%%% ====================================================================
%%% Part 16: 列表推导式 (List Comprehensions)
%%% ====================================================================
%%% 列表推导式是 Erlang 中创建和转换列表的简洁方式：
%%% - 语法：[表达式 || 生成器1, 生成器2, ..., 过滤器1, 过滤器2, ...]
%%% - 生成器：变量 <- 列表，用于遍历列表元素
%%% - 过滤器：布尔表达式，用于过滤元素
%%%
%%% 列表推导式的优点：
%%% - 代码更简洁易读
%%% - 避免显式的递归
%%% - 功能强大，支持多生成器和多过滤器
%%%
%%% 列表推导式的应用：
%%% - 数据转换
%%% - 数据过滤
%%% - 笛卡尔积生成
%%% - 复杂数据处理
%%% ====================================================================
list_comprehensions_test() ->
    %% 第6章：标准库 - Part 16: 列表推导式
    io:format("\n=== 第6章：标准库 - Part 16: 列表推导式 ===\n"),
    
    %% 基本列表推导式：将每个元素乘以 2
    ?assertEqual([2, 4, 6], [X * 2 || X <- [1, 2, 3]]),
    
    %% 带过滤器的列表推导式：过滤出偶数
    ?assertEqual([2, 4], [X || X <- [1, 2, 3, 4], X rem 2 == 0]),
    
    %% 多生成器的列表推导式：生成笛卡尔积
    ?assertEqual([{1, a}, {1, b}, {2, a}, {2, b}], [{X, Y} || X <- [1, 2], Y <- [a, b]]).

%%% ====================================================================
%%% Part 17: 记录 (Records)
%%% ====================================================================
%%% 记录是 Erlang 中类似于结构体的数据结构：
%%% - 用于组织相关的字段数据
%%% - 定义语法：-record(record_name, {field1, field2, ...}).
%%% - 创建语法：#record_name{field1 = value1, field2 = value2, ...}
%%% - 访问语法：Record#record_name.field
%%% - 更新语法：Record#record_name{field = new_value}
%%%
%%% 记录的优点：
%%% - 代码更具可读性
%%% - 字段访问更直观
%%% - 类似于其他语言中的结构体或对象
%%%
%%% 记录的应用：
%%% - 表示实体（如用户、订单等）
%%% - 配置数据
%%% - 消息格式
%%%
%%% 注意：
%%% - 记录在编译时会被转换为元组
%%% - 通常在 .hrl 头文件中定义记录
%%% ====================================================================
-record(person, {name, age, city}).

records_test() ->
    %% 第3章：数据结构 - Part 17: 记录
    io:format("\n=== 第3章：数据结构 - Part 17: 记录 ===\n"),
    
    %% 创建记录实例
    Person = #person{name = "John", age = 30, city = "New York"},
    
    %% 访问记录字段
    ?assertEqual("John", Person#person.name),
    ?assertEqual(30, Person#person.age),
    ?assertEqual("New York", Person#person.city),
    
    %% 更新记录字段（返回新记录，原记录不变）
    UpdatedPerson = Person#person{age = 31},
    ?assertEqual(31, UpdatedPerson#person.age).

%%% ====================================================================
%%% Chapter 7: 并发编程 (Concurrency)
%%% ====================================================================

%%% ====================================================================
%%% Part 15: 进程和消息传递 (Processes & Message Passing)
%%% ====================================================================
%%% 进程是 Erlang 并发模型的核心：
%%% - Erlang 进程是轻量级的，内存占用小，创建和销毁快
%%% - 进程之间通过消息传递通信，而不是共享内存
%%% - 每个进程有一个唯一的进程标识符（PID）
%%%
%%% 基本操作：
%%% - spawn/1：创建新进程
%%% - !：发送消息
%%% - receive：接收消息
%%% - self()：获取当前进程的 PID
%%% ====================================================================
processes_test() ->
    %% 第7章：并发编程 - Part 15: 进程和消息传递
    io:format("\n=== 第7章：并发编程 - Part 15: 进程和消息传递 ===\n"),
    
    %% 创建一个简单的进程
    Pid = spawn(fun() ->
        receive
            {From, Message} ->
                From ! {self(), "Received: " ++ Message}
        end
    end),
    
    %% 发送消息给进程
    Pid ! {self(), "Hello Process"},
    
    %% 接收进程的回复
    receive
        {Pid, Response} ->
            ?assertEqual("Received: Hello Process", Response)
    after 1000 ->
        ?assert(false, "No response from process")
    end.

%%% ====================================================================
%%% Part 16: 进程链接和监视器 (Process Links & Monitors)
%%% ====================================================================
%%% 进程链接和监视器用于处理进程间的错误传播：
%%%
%%% 1. 进程链接 (Links)：
%%%    - 使用 spawn_link/1 创建链接的进程
%%%    - 当一个进程崩溃时，链接的进程也会崩溃
%%%    - 用于需要共同失败的进程组
%%%
%%% 2. 进程监视器 (Monitors)：
%%%    - 使用 monitor/1 监控进程
%%%    - 当被监控的进程崩溃时，监控进程会收到通知
%%%    - 用于需要知道其他进程状态的场景
%%% ====================================================================
process_links_monitors_test() ->
    %% 第7章：并发编程 - Part 16: 进程链接和监视器
    io:format("\n=== 第7章：并发编程 - Part 16: 进程链接和监视器 ===\n"),
    
    %% 测试进程监视器
    TestPid = self(),
    
    %% 创建一个进程，然后监控它
    Pid = spawn(fun() ->
        receive
            crash ->
                exit(crash_reason)
        end
    end),
    
    %% 监控进程
    MonitorRef = monitor(process, Pid),
    
    %% 让进程崩溃
    Pid ! crash,
    
    %% 接收监控通知
    receive
        {'DOWN', MonitorRef, process, Pid, crash_reason} ->
            ?assert(true)
    after 1000 ->
        ?assert(false, "No monitor notification received")
    end.

%%% ====================================================================
%%% Part 17: gen_server
%%% ====================================================================
%%% gen_server 是 Erlang OTP 中的通用服务器行为模式：
%%% - 提供了一个标准化的服务器实现框架
%%% - 处理请求、响应、状态管理等通用逻辑
%%% - 支持同步调用、异步消息和定时消息
%%%
%%% 基本回调函数：
%%% - init/1：初始化服务器状态
%%% - handle_call/3：处理同步调用
%%% - handle_cast/2：处理异步消息
%%% - handle_info/2：处理其他消息
%%% - terminate/2：服务器终止时的清理工作
%%% ====================================================================
%%% 注意：完整的 gen_server 实现通常在单独的模块中，
%%% 这里只展示基本概念的测试

gen_server_test() ->
    %% 第7章：并发编程 - Part 17: gen_server
    io:format("\n=== 第7章：并发编程 - Part 17: gen_server ===\n"),
    
    %% 简单测试 gen_server 概念
    ?assert(true, "gen_server 概念测试通过").

%%% ====================================================================
%%% Part 18: Supervisor
%%% ====================================================================
%%% Supervisor 是 Erlang OTP 中的监督器行为模式：
%%% - 用于监控和管理其他进程（被监督进程）
%%% - 当被监督进程崩溃时，根据重启策略进行重启
%%% - 支持多种重启策略：one_for_one, one_for_all, rest_for_one, simple_one_for_one
%%%
%%% 基本功能：
%%% - 管理进程的生命周期
%%% - 实现故障恢复
%%% - 构建容错系统
%%% ====================================================================
%%% 注意：完整的 supervisor 实现通常在单独的模块中，
%%% 这里只展示基本概念的测试
supervisor_test() ->
    %% 第7章：并发编程 - Part 18: Supervisor
    io:format("\n=== 第7章：并发编程 - Part 18: Supervisor ===\n"),
    
    %% 简单测试 supervisor 概念
    ?assert(true, "supervisor 概念测试通过").

%%% ====================================================================
%%% Part 19: Application
%%% ====================================================================
%%% Application 是 Erlang OTP 中的应用行为模式：
%%% - 表示一个完整的 Erlang 应用
%%% - 管理应用的生命周期
%%% - 处理应用的启动和停止
%%%
%%% 基本文件：
%%% - .app 文件：应用的元数据
%%% - application 行为实现模块
%%%
%%% 启动类型：
%%% - permanent：应用崩溃时，整个节点崩溃
%%% - transient：应用正常终止时，节点继续运行
%%% - temporary：应用崩溃时，节点继续运行
%%% ====================================================================
%%% 注意：完整的 application 实现通常在单独的模块中，
%%% 这里只展示基本概念的测试

application_test() ->
    %% 第7章：并发编程 - Part 19: Application
    io:format("\n=== 第7章：并发编程 - Part 19: Application ===\n"),
    
    %% 简单测试 application 概念
    ?assert(true, "application 概念测试通过").

%%% ====================================================================
%%% Chapter 6: 标准库 (Standard Library)
%%% ====================================================================

%%% ====================================================================
%%% Part 21: 二进制模块 (Binary Module)
%%% ====================================================================
%%% binary 模块提供了处理二进制数据的函数：
%%% - binary:part/3：提取二进制的一部分
%%% - binary:bin_to_list/1：二进制转换为字符列表
%%% - binary:list_to_bin/1：字符列表转换为二进制
%%% - binary:split/2：分割二进制
%%% - binary:replace/3：替换二进制中的内容
%%% ====================================================================
binary_module_test() ->
    %% 第6章：标准库 - Part 21: 二进制模块
    io:format("\n=== 第6章：标准库 - Part 21: 二进制模块 ===\n"),
    
    Bin = <<"Hello, World!">>,
    
    %% 提取二进制的一部分
    ?assertEqual(<<"Hello">>, binary:part(Bin, 0, 5)),
    
    %% 二进制转换为字符列表
    ?assertEqual("Hello, World!", binary:bin_to_list(Bin)),
    
    %% 字符列表转换为二进制
    ?assertEqual(Bin, binary:list_to_bin("Hello, World!")),
    
    %% 分割二进制
    ?assertEqual([<<"Hello">>, <<" World!">>], binary:split(Bin, <<",">>)),
    
    %% 替换二进制中的内容
    ?assertEqual(<<"Hello, Erlang!">>, binary:replace(Bin, <<"World">>, <<"Erlang">>)).

%%% ====================================================================
%%% Part 22: 加密模块 (Crypto Module)
%%% ====================================================================
%%% crypto 模块提供了加密相关的功能：
%%% - 哈希函数：md5, sha, sha256 等
%%% - 消息认证码：hmac
%%% - 加密/解密：aes, des 等
%%% - 随机数生成
%%% ====================================================================
crypto_module_test() ->
    %% 第6章：标准库 - Part 22: 加密模块
    io:format("\n=== 第6章：标准库 - Part 22: 加密模块 ===\n"),
    
    Data = <<"test data">>,
    
    %% 测试 MD5 哈希
    MD5Hash = crypto:hash(md5, Data),
    ?assert(is_binary(MD5Hash)),
    ?assertEqual(16, byte_size(MD5Hash)),
    
    %% 测试 SHA256 哈希
    SHA256Hash = crypto:hash(sha256, Data),
    ?assert(is_binary(SHA256Hash)),
    ?assertEqual(32, byte_size(SHA256Hash)).

%%% ====================================================================
%%% Part 26: 文件 I/O (File I/O)
%%% ====================================================================
%%% file 模块提供了文件操作的功能：
%%% - file:read_file/1：读取整个文件
%%% - file:write_file/2：写入整个文件
%%% - file:open/2：打开文件
%%% - file:close/1：关闭文件
%%% - file:list_dir/1：列出目录内容
%%% ====================================================================
file_io_test() ->
    %% 第6章：标准库 - Part 26: 文件 I/O
    io:format("\n=== 第6章：标准库 - Part 26: 文件 I/O ===\n"),
    
    %% 测试文件写入和读取
    TestFile = "test_file.txt",
    TestContent = "Hello, File I/O!",
    
    %% 写入文件
    ok = file:write_file(TestFile, TestContent),
    
    %% 读取文件
    {ok, Content} = file:read_file(TestFile),
    ?assertEqual(list_to_binary(TestContent), Content),
    
    %% 删除测试文件
    ok = file:delete(TestFile).

%%% ====================================================================
%%% Part 27: 正则表达式 (Regular Expressions)
%%% ====================================================================
%%% 正则表达式在 Erlang 中通过 re 模块实现：
%%% - re:run/2：执行正则表达式匹配
%%% - re:replace/3：使用正则表达式替换
%%% - re:compile/1：编译正则表达式
%%% ====================================================================
regular_expressions_test() ->
    %% 第6章：标准库 - Part 27: 正则表达式
    io:format("\n=== 第6章：标准库 - Part 27: 正则表达式 ===\n"),
    
    Text = "Hello, Erlang 2024!",
    
    %% 测试正则表达式匹配
    {match, _} = re:run(Text, "Erlang"),
    
    %% 测试正则表达式替换
    NewText = re:replace(Text, "2024", "2026", [{return, binary}]),
    ?assertEqual(<<"Hello, Erlang 2026!">>, NewText).

%%% ====================================================================
%%% Chapter 8: 高级主题 (Advanced Topics)
%%% ====================================================================

%%% ====================================================================
%%% Part 28: ETS (Erlang Term Storage)
%%% ====================================================================
%%% ETS 是 Erlang 中的内存数据库：
%%% - 用于存储大量数据，提供快速访问
%%% - 支持多种表类型：set, ordered_set, bag, duplicate_bag
%%% - 由创建进程拥有，进程终止时表自动销毁
%%%
%%% 基本操作：
%%% - ets:new/2：创建新表
%%% - ets:insert/2：插入数据
%%% - ets:lookup/2：查找数据
%%% - ets:delete/2：删除数据
%%% - ets:delete/1：删除表
%%% ====================================================================
ets_test() ->
    %% 第8章：高级主题 - Part 28: ETS (Erlang Term Storage)
    io:format("\n=== 第8章：高级主题 - Part 28: ETS (Erlang Term Storage) ===\n"),
    
    %% 创建 ETS 表
    TableId = ets:new(test_table, [set]),
    
    %% 插入数据
    ets:insert(TableId, {key1, value1}),
    ets:insert(TableId, {key2, value2}),
    
    %% 查找数据
    ?assertEqual([{key1, value1}], ets:lookup(TableId, key1)),
    ?assertEqual([{key2, value2}], ets:lookup(TableId, key2)),
    
    %% 删除数据
    ets:delete(TableId, key1),
    ?assertEqual([], ets:lookup(TableId, key1)),
    
    %% 删除表
    ets:delete(TableId).

%%% ====================================================================
%%% Part 29: 定时器函数 (Timer Functions)
%%% ====================================================================
%%% timer 模块提供了定时器相关的功能：
%%% - timer:sleep/1：让进程睡眠指定时间
%%% - timer:send_after/2：在指定时间后发送消息
%%% - timer:apply_after/3：在指定时间后调用函数
%%% - timer:start/0：启动定时器服务器
%%% ====================================================================
timer_functions_test() ->
    %% 第8章：高级主题 - Part 29: 定时器函数
    io:format("\n=== 第8章：高级主题 - Part 29: 定时器函数 ===\n"),
    
    %% 测试定时器消息
    TestPid = self(),
    
    %% 设置一个定时器，100毫秒后发送消息
    Ref = timer:send_after(100, {timer_event, test}),
    
    %% 接收定时器消息
    receive
        {timer_event, test} ->
            ?assert(true)
    after 500 ->
        ?assert(false, "No timer event received")
    end.

%%% ====================================================================
%%% Part 30: 队列数据结构 (Queue Data Structure)
%%% ====================================================================
%%% queue 模块提供了高效的队列实现：
%%% - 基于双链表，支持从两端高效操作
%%% - 适合 FIFO（先进先出）场景
%%%
%%% 基本操作：
%%% - queue:new/0：创建新队列
%%% - queue:in/2：向队列添加元素
%%% - queue:out/1：从队列取出元素
%%% - queue:len/1：获取队列长度
%%% - queue:is_empty/1：检查队列是否为空
%%% ====================================================================
queue_test() ->
    %% 第8章：高级主题 - Part 30: 队列数据结构
    io:format("\n=== 第8章：高级主题 - Part 30: 队列数据结构 ===\n"),
    
    %% 创建新队列
    Q1 = queue:new(),
    ?assert(queue:is_empty(Q1)),
    
    %% 向队列添加元素
    Q2 = queue:in(1, Q1),
    Q3 = queue:in(2, Q2),
    Q4 = queue:in(3, Q3),
    ?assertEqual(3, queue:len(Q4)),
    
    %% 从队列取出元素
    {{value, 1}, Q5} = queue:out(Q4),
    {{value, 2}, Q6} = queue:out(Q5),
    {{value, 3}, Q7} = queue:out(Q6),
    ?assert(queue:is_empty(Q7)).

%%% ====================================================================
%%% Part 31: 端口 (外部程序) (Ports (External Programs))
%%% ====================================================================
%%% 端口用于 Erlang 与外部程序的通信：
%%% - 端口是 Erlang 与外部世界之间的接口
%%% - 支持与用其他语言编写的程序通信
%%% - 数据通过标准输入/输出流传递
%%%
%%% 基本操作：
%%% - open_port/2：打开端口
%%% - port_command/2：向端口发送命令
%%% - receive：接收端口的输出
%%% - port_close/1：关闭端口
%%% ====================================================================
ports_test() ->
    %% 第8章：高级主题 - Part 31: 端口 (外部程序)
    io:format("\n=== 第8章：高级主题 - Part 31: 端口 (外部程序) ===\n"),
    
    %% 测试与外部命令的通信
    %% 注意：这里使用 echo 命令作为示例，实际使用中要注意安全性
    Port = open_port({spawn, "echo hello"}, [binary]),
    
    %% 接收端口的输出
    receive
        {Port, {data, Data}} ->
            ?assertEqual(<<"hello\n">>, Data)
    after 1000 ->
        ?assert(false, "No output from port")
    end,
    
    %% 关闭端口
    port_close(Port).

%%% ====================================================================
%%% Part 32: 引用类型 (Reference Type)
%%% ====================================================================
%%% 引用是 Erlang 中的一种唯一标识符：
%%% - 使用 make_ref/0 创建
%%% - 每次调用 make_ref/0 都会生成一个唯一的引用
%%% - 常用于：
%%%   * 作为唯一标识符
%%%   * 防止消息重复处理
%%%   * 实现请求-响应模式
%%% ====================================================================
reference_type_test() ->
    %% 第8章：高级主题 - Part 32: 引用类型
    io:format("\n=== 第8章：高级主题 - Part 32: 引用类型 ===\n"),
    
    %% 创建引用
    Ref1 = make_ref(),
    Ref2 = make_ref(),
    
    %% 验证引用是唯一的
    ?assertNot(Ref1 =:= Ref2),
    
    %% 验证引用类型
    ?assert(is_reference(Ref1)),
    ?assert(is_reference(Ref2)).

%%% ====================================================================
%%% Part 33: 属性列表 (Proplists)
%%% ====================================================================
%%% proplists 模块提供了处理属性列表的功能：
%%% - 属性列表是形如 [{key1, value1}, {key2, value2}] 的列表
%%% - 适合存储配置和选项
%%%
%%% 基本操作：
%%% - proplists:get_value/2：获取属性值
%%% - proplists:is_defined/2：检查属性是否存在
%%% - proplists:delete/2：删除属性
%%% - proplists:append/3：追加属性值
%%% ====================================================================
proplists_test() ->
    %% 第8章：高级主题 - Part 33: 属性列表
    io:format("\n=== 第8章：高级主题 - Part 33: 属性列表 ===\n"),
    
    Props = [{name, "John"}, {age, 30}, {city, "New York"}],
    
    %% 获取属性值
    ?assertEqual("John", proplists:get_value(name, Props)),
    ?assertEqual(30, proplists:get_value(age, Props)),
    
    %% 检查属性是否存在
    ?assert(proplists:is_defined(name, Props)),
    ?assertNot(proplists:is_defined(country, Props)),
    
    %% 删除属性
    NewProps = proplists:delete(age, Props),
    ?assertNot(proplists:is_defined(age, NewProps)).

%%% ====================================================================
%%% Part 34: 位运算 (Bitwise Operations)
%%% ====================================================================
%%% Erlang 支持基本的位运算：
%%% - band：按位与
%%% - bor：按位或
%%% - bxor：按位异或
%%% - bnot：按位取反
%%% - bsl：左移位
%%% - bsr：右移位
%%% ====================================================================
bitwise_operations_test() ->
    %% 第8章：高级主题 - Part 34: 位运算
    io:format("\n=== 第8章：高级主题 - Part 34: 位运算 ===\n"),
    
    A = 2#1010,  %% 10
    B = 2#1100,  %% 12
    
    %% 按位与
    ?assertEqual(2#1000, A band B),  %% 8
    
    %% 按位或
    ?assertEqual(2#1110, A bor B),   %% 14
    
    %% 按位异或
    ?assertEqual(2#0110, A bxor B),  %% 6
    
    %% 左移位
    ?assertEqual(2#10100, A bsl 1),  %% 20
    
    %% 右移位
    ?assertEqual(2#101, A bsr 1).    %% 5

%%% ====================================================================
%%% Part 35: 系统内省 (System Introspection)
%%% ====================================================================
%%% Erlang 提供了系统内省的功能：
%%% - erlang:system_info/1：获取系统信息
%%% - erlang:process_info/1：获取进程信息
%%% - erlang:module_info/1：获取模块信息
%%% - registered/0：获取注册的进程名
%%% ====================================================================
system_introspection_test() ->
    %% 第8章：高级主题 - Part 35: 系统内省
    io:format("\n=== 第8章：高级主题 - Part 35: 系统内省 ===\n"),
    
    %% 获取系统信息
    OtpVersion = erlang:system_info(otp_release),
    ?assert(is_list(OtpVersion)),
    
    %% 获取当前进程信息
    ProcessInfo = erlang:process_info(self()),
    ?assert(is_list(ProcessInfo)),
    
    %% 获取注册的进程名
    Registered = registered(),
    ?assert(is_list(Registered)).

%%% ====================================================================
%%% Chapter 9: 模块系统和组织 (Module System & Organization)
%%% ====================================================================

%%% ====================================================================
%%% Part 37: 编译指令 (Compile Directives)
%%% ====================================================================
%%% 编译指令用于控制 Erlang 编译器的行为：
%%% - -module/1：定义模块名
%%% - -export/1：导出函数
%%% - -import/2：导入其他模块的函数
%%% - -record/2：定义记录
%%% - -define/2：定义宏
%%% - -compile/1：设置编译选项
%%%
%%% 常用编译选项：
%%% - debug_info：生成调试信息
%%% - export_all：导出所有函数
%%% - warnings_as_errors：将警告视为错误
%%% ====================================================================
%%% 注意：编译指令通常在模块文件的开头定义，
%%% 这里只展示基本概念的测试

compile_directives_test() ->
    %% 第9章：模块系统和组织 - Part 37: 编译指令
    io:format("\n=== 第9章：模块系统和组织 - Part 37: 编译指令 ===\n"),
    
    %% 测试宏定义和使用
    %% 注意：宏定义通常在模块顶部，这里只展示概念
    PI = 3.14159,
    ?assertEqual(3.14159, PI).

%%% ====================================================================
%%% Part 38: 类型规范 (Type Specifications)
%%% ====================================================================
%%% 类型规范用于为 Erlang 代码添加类型信息：
%%% - 使用 -spec 指令定义函数的类型规范
%%% - 帮助 Dialyzer 等静态分析工具检测类型错误
%%% - 提高代码的可读性和可维护性
%%%
%%% 基本语法：
%%% -spec function_name(ArgType1, ArgType2) -> ReturnType.
%%%
%%% 常用类型：
%%% - 基本类型：integer(), float(), atom(), binary(), list() 等
%%% - 复合类型：{Type1, Type2}, [Type], #{KeyType => ValueType} 等
%%% - 自定义类型：使用 -type 指令定义
%%% ====================================================================
%%% 注意：类型规范通常在函数定义前使用，
%%% 这里只展示基本概念的测试
type_specifications_test() ->
    %% 第9章：模块系统和组织 - Part 38: 类型规范
    io:format("\n=== 第9章：模块系统和组织 - Part 38: 类型规范 ===\n"),
    
    %% 测试基本类型
    Integer = 42,
    Float = 3.14,
    Atom = ok,
    Binary = <<"test">>,
    List = [1, 2, 3],
    
    ?assert(is_integer(Integer)),
    ?assert(is_float(Float)),
    ?assert(is_atom(Atom)),
    ?assert(is_binary(Binary)),
    ?assert(is_list(List)).

%%% ====================================================================
%%% Chapter 10: NIFs (Native Implemented Functions)
%%% ====================================================================
%%% NIFs 相关内容不在此测试文件中展示，原因如下：
%%%
%%% 1. Part 39: C NIFs Basics
%%%    - 需要编写 C 代码并编译为共享库
%%%    - 涉及平台相关的编译和链接
%%%    - 不适合在纯 Erlang 测试文件中展示
%%%
%%% 2. Part 40: Working with Binaries in NIFs
%%%    - 同样需要 C 代码实现
%%%    - 涉及 Erlang 二进制与 C 数据的转换
%%%    - 需要复杂的内存管理
%%%
%%% 3. Part 41: Rustler NIFs
%%%    - 需要 Rust 开发环境
%%%    - 需要编译 Rust 代码为 NIF
%%%    - 依赖 Rustler 库
%%%
%%% 4. Part 42: NIF Best Practices
%%%    - 是关于 NIF 开发的最佳实践指南
%%%    - 没有具体的测试代码可展示
%%%    - 涉及性能优化和安全考虑
%%%
%%% NIFs 是 Erlang 与原生代码交互的高级特性，
%%% 适合在专门的项目中实现和测试，而不是在基础语言测试文件中。
%%% ====================================================================
